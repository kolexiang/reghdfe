

recalcular el p es CARISIMO
asi que tengo que buscar una forma mas facil

en cada loop que hago?

1. copio ivars N * Kg
2. creo p, el vector que sirve para ordenar cualq variable segun ivars a lo foobar[p]
	notar que el orden creado por p no es estable
3. ordeno ivars segun p
4. creo delta = ivars != L.ivars












Que quiero COMO ULTIMO OBJETIVO!?

(opcionalmente) en el DTA, una variable FE# para cada categoria (que sea cero si es singleton)

en mata, para cada g,
1) scalar levels
2) vector[levels] count (ponderado x los weights); eso es para el denominador y para el offset al iterar dentro de los 3) vectores de permutacion para sacar las sumas

	algo como
		count = counts[i]
		means = sum(y[| offset \ offset + count - 1 |]) / count
		offset = offset + count

una forma para ordenar el dataset, o sobretodo, vectores N*1 con las proyecciones parciales, segun la dimension que quiera



preserve
	ParseAbsvars

	keep if..
	keep ..
	gen ..
	keep.. (ETC)

	mapsolve_init
	SORT por el primer fe (HACERLO ACA, NO antes cuadno haga conflicto con las expansiones de L.)
	PROBLEMA: si despues tengo un VCE complejo HAC, va a querer que la data este tsseteada
	una solucion puede ser envolver el mapsolve en un sortpreserve


dado que de por si necesito hacer preserve (PORQUE CREO VARIABLES, ME BAJO VARIABLES PARA Q TODO ENTRE EN EL DATASET, ETC)

entonces simplemente BORRAR A LOS SINGLETONS PARA NO SEGUIR PENSANDO EN ELLOS


tengo un vector singleton ordenado tal como en el dta
hago st_dropobsif(singleton)

ahora tengo que arreglar los p's

5 2 4 3 1 -> 5-1=4 2 X 3 1

creo sum_singletons = runningsum(singleton)
hago p = select(p - sum_singletons[p], !singleton)


eres singleton si tienes 1..1 en el vector deltas, epro

	cou
	gen byte singleton = 0

	for g=1..G
		bys `ivars_g': replace singleton = singleton | (_N==1)
		gen idg = sum(_n==1 & !singleton)
		replace idg = 0 if singleton
		inmediately drop an ivar if not used in clustervars + panelvar + timevar + future ivars + cvars + regression
		notar q en realidad no deberian haber ivars q tb esten en la regresion.. asi q ignorar el ultimo
		panelvar y timevar lo puedo sacar yo mismo, asi q solo necesito clustervars

	(repetir para g=2..G)
	new_cou = c(N)

while new cou < old cou,
	cou = new_cou
	bys id1: drop if _N==1
	(repetir para g==2..G)
	new_cou = c(N)

El problema es que voy a hacer un culo de SORTS
Y aparte creoooo +- que droppear a cada rato es peor que taggear y dropear una sola vez

Mejor:

	cou

	if firstpass:
		id = st_data(ivars)
		p = order(id)
	
	id = id[p] // collate

	changed = id != L.id // optimizado

	id = runningsum(changed)
	
	if cols(id)>1
		drop unneeded ivars

	pero ahora el p no sirve

	singleton = singleton :& changed (+-)



	sample = J(N,1,1)
	while (..)
		if firstpass:
			id = st_data(sample, ivars)





